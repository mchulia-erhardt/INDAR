# Diseño y Análisis: Oracle 19c + Java 11 + JPA/Hibernate con JSON

## Introducción
Este documento combina el análisis de la opción JSON en Oracle 19c y el diseño técnico completo para gestionar usuarios, perfiles y versiones, integrado con Java 11 y JPA/Hibernate.

---

## 1. Análisis de la opción JSON en Oracle 19c
### ¿Por qué JSON es la opción aconsejable?
- Oracle 19c soporta validación nativa de JSON (`IS JSON`) y funciones específicas para manipulación.
- JSON es más ligero y ampliamente utilizado en aplicaciones modernas, especialmente en entornos Java y APIs REST.
- Evita la conversión XML → JSON, reduciendo complejidad y mejorando rendimiento.
- Permite consultas eficientes con funciones como `JSON_VALUE`, `JSON_QUERY` y `JSON_TABLE`.

### PROs
- Compatibilidad nativa con Oracle.
- Flexibilidad para añadir atributos sin modificar el esquema.
- Integración sencilla con Java (Jackson, Gson).
- Indexación optimizada para consultas JSON.
- Menor tamaño y complejidad que XML.

### Contras
- Validación estructural limitada (XML permite XSD).
- Menos adecuado para datos muy jerárquicos.
- Consultas avanzadas requieren sintaxis JSONPath.

### Comparativa con XML
| Aspecto              | JSON en Oracle 19c       | XML en Oracle 19c          |
|----------------------|---------------------------|-----------------------------|
| Soporte nativo       | Sí (IS JSON, JSON_VALUE) | Sí (XMLTYPE, XPath/XQuery) |
| Facilidad en Java    | Alta                     | Baja (requiere conversión) |
| Validación estricta  | Limitada                 | Alta (XSD)                 |
| Tamaño y rendimiento | Mejor                    | Peor                       |

### Conclusión
Para un sistema que necesita flexibilidad, escalabilidad y fácil integración con Java, **JSON en Oracle 19c es la opción más aconsejable**.

---

## 2. Diseño técnico
### Lógica del diseño
- Un usuario puede tener múltiples perfiles.
- Cada perfil puede evolucionar con el tiempo (versionado).
- Se utiliza JSON para almacenar atributos dinámicos.
- Las versiones permiten mantener la integridad histórica.

**Flujo de trabajo:**
1. Crear usuario.
2. Asignar perfil y guardar atributos en JSON.
3. Crear instalación referenciando la versión exacta.
4. Consultar instalación y recuperar JSON histórico.

---

## 3. Scripts SQL
```sql
CREATE TABLE Usuario (
    id_usuario NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nif VARCHAR2(20) UNIQUE NOT NULL,
    nombre VARCHAR2(100),
    email VARCHAR2(100),
    activo CHAR(1) DEFAULT 'Y'
);

CREATE TABLE Perfil (
    id_perfil NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    nombre_perfil VARCHAR2(50) NOT NULL,
    descripcion VARCHAR2(255)
);

CREATE TABLE Usuario_Perfil_Version (
    id_version NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_usuario NUMBER NOT NULL,
    id_perfil NUMBER NOT NULL,
    version NUMBER NOT NULL,
    datos CLOB CHECK (datos IS JSON),
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_usuario FOREIGN KEY (id_usuario) REFERENCES Usuario(id_usuario),
    CONSTRAINT fk_perfil FOREIGN KEY (id_perfil) REFERENCES Perfil(id_perfil)
);

CREATE TABLE Instalacion (
    id_instalacion NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    id_usuario NUMBER NOT NULL,
    id_perfil NUMBER NOT NULL,
    id_version NUMBER NOT NULL,
    datos CLOB CHECK (datos IS JSON),
    fecha_creacion TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_usuario_dec FOREIGN KEY (id_usuario) REFERENCES Usuario(id_usuario),
    CONSTRAINT fk_perfil_dec FOREIGN KEY (id_perfil) REFERENCES Perfil(id_perfil),
    CONSTRAINT fk_version_dec FOREIGN KEY (id_version) REFERENCES Usuario_Perfil_Version(id_version)
);
```

---

## 4. Consultas JSON en Oracle
```sql
SELECT JSON_VALUE(datos, '$.razon_social') AS razon_social
FROM Usuario_Perfil_Version
WHERE id_version = 10;

SELECT datos FROM Usuario_Perfil_Version WHERE id_version = 10;
```

---

## 5. Entidad JPA
```java
@Entity
@Table(name = "Usuario_Perfil_Version")
public class UsuarioPerfilVersion {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long idVersion;

    @ManyToOne
    private Usuario usuario;

    @ManyToOne
    private Perfil perfil;

    private Integer version;

    @Lob
    @Column(name = "datos")
    private String datosJson;
}
```

---

## 6. Buenas prácticas
- Validación JSON con `CHECK IS JSON`.
- Indexación con `JSON_VALUE`.
- Control de versiones.

---

## 7. Ejemplo práctico completo
### SQL
```sql
INSERT INTO Usuario (nif, nombre, email) VALUES ('12345678X', 'Pepito', 'pepito@mail.com');
INSERT INTO Perfil (nombre_perfil, descripcion) VALUES ('Empresa', 'Perfil para empresas');
INSERT INTO Usuario_Perfil_Version (id_usuario, id_perfil, version, datos)
VALUES (1, 1, 2025, '{"razon_social":"Mercadona","cif":"B12345678"}');
INSERT INTO Instalacion (id_usuario, id_perfil, id_version, datos)
VALUES (1, 1, 1, '{"ubicacion":"Valencia","fecha":"2025-11-18"}');
```

### Java
```java
import com.fasterxml.jackson.databind.ObjectMapper;
import java.util.Map;

public String convertJsonToPretty(String jsonData) throws Exception {
    ObjectMapper mapper = new ObjectMapper();
    Map<String, Object> map = mapper.readValue(jsonData, Map.class);
    return mapper.writerWithDefaultPrettyPrinter().writeValueAsString(map);
}

String perfilJson = "{"razon_social":"Mercadona","cif":"B12345678"}";
String prettyJson = convertJsonToPretty(perfilJson);
System.out.println(prettyJson);
```

---

## Conclusión
La opción JSON en Oracle 19c ofrece la mejor combinación de flexibilidad, rendimiento y facilidad de integración con Java, siendo ideal para sistemas que requieren versionado y atributos dinámicos.
